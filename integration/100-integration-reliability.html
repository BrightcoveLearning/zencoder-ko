
---
title: 100% 통합 안정성
description: '이 항목에서는 Zencoder에 연결할 수 없는 이유와 안정적인 통합을 보장하는 방법에 대해 설명합니다.'
parent: Integration
---
 <h1>{{ page.title }}</h1>
<article class="bcls-article">
  <summary>{{ page.description }}</summary>

  <section class="bcls-section">
    <h2 id="Overview">개요</h2>

    <p>Zencoder는 대부분의 고객에게 필수적인 소프트웨어 종속성입니다. 그리고 100 % 가동 시간을 목표로하지만 Zencoder에 연결할 수없는 경우가있을 수 있습니다.</p>

    <p>이런 일이 발생하고 Zencoder가 다운되면 애플리케이션은 일반적으로 Zencoder에서 '503 서비스 사용할 수 없는' 응답을 받지만 다른 오류 (예: 500) 가 발생할 수 있습니다. API 속도 한도를 초과하면 '403 속도 한도 초과' 응답이 표시됩니다.</p>

    <p>좋은 소식: 비디오 인코딩은 비동기 프로세스이므로 가동 중지 시간이나 가용성과 관련된 문제가 발생하지 않도록 애플리케이션을 구축할 수 있습니다. 이렇게하면 최악의 시나리오는 작업이 조금 더 오래 걸리는 것입니다. 그러나 오류는 발생하지 않습니다. 이렇게하는 것이 좋습니다.</p>

    <p>보다 강력하게 말하면, 안정성에 관심이<strong>있다면 Zencoder 또는</strong>통합하는 중요한 API에 대한 통합에 대한 이러한 접근 방식을 따라야 합니다.</p>

    <ul>
      <li>아마존 서비스는 업스트림 제공업체의 문제 (예: Amazon Web Services) 의 영향을 받을 수 있습니다.</li>
      <li>때때로 일시적인 다운 타임이 필요한 시스템 유지 관리를 수행해야합니다.</li>
      <li><a href="/general-information/faq-rate-limiting.html">API 속도 한도를 초과했습니다.</a></li>
      <li>기타</li>
    </ul>
  </section>
  <section class="bcls-section">
    <h2 id="Reliable_app_integration">안정적인 앱 통합</h2>

    <ol>
      <li>기본 위치로 업로드가 실패할 경우<a href="/encoding-settings/general/encoding-settings-general-output-settings.html#secondary-url">보조 URL을</a>백업으로 포함합니다.</li>
      <li>Zencoder에서 실패한 응답 코드 (기본적으로 200 또는 201 이외의) 를 얻으면 작업을 실패하지<strong>마십시오</strong> . 응답 코드 503은 동영상을 처리 할 수 없음을 의미하지 않습니다. Zencoder를 일시적으로 사용할 수 없음을 의미합니다.</li>
      <li>당신이 얻을 경우<strong>연결 오류</strong> Zencoder에 연결하려고 할 때 동일한 작업을 수행합니다.</li>
      <li>마찬가지로 API 요청을 시간 초과로<strong></strong>래핑합니다. 30초 시간 초과를 권장합니다. Zencoder는 보통 1초 이내에 응답하므로 일반적으로 30초는 충분한 시간입니다.</li>
      <li>이 세 가지 경우 모두-성공하지 못한 응답 코드를 받거나 연결할 수 없거나 API 요청 시간이 초과 된 경우- <strong>작업을 '보류 중'으로 표시하십시오.</strong></li>
      <li>주기적으로, <strong>보류 중인 작업을 다시 제출하십시오'' </strong>상태 . 예를 들어 cron을 사용하여 매분마다이 작업을 수행 할 수 있습니다.</li>
    </ol>
    <p>작업이 다시 제출되면 모든 것이 정상적으로 작동합니다. 이렇게하면 작업 제출에 실패하면 응용 프로그램이나 사용자에게 문제를 일으키지 않고 작업 시간이 조금 더 걸립니다.</p>
  </section>
  <section class="bcls-section">
    <h2 id="Pseudocode">의사 코드</h2>

    <p>좋습니다. 이것은 의사 코드가 아닙니다. Ruby입니다. 하지만 Ruby는 읽기가 매우 쉽습니다.</p>

    <ol>
      <li>이러한 열이 포함 된 비디오 테이블을 상상해보십시오. (Zencoder 작업 ID 및 Zencoder 출력 파일 ID를 저장하는 열을 포함하여 분명히 더 많은 것이 있습니다.)
        <pre class="line-numbers">
<code class="language-ruby" translate="No">create_table :videos do |t|
t.string  :state
t.integer :lock_version
t.index   :state
end</code></pre>
      </li>
      <li>비디오에는 다음 상태의 상태 시스템이 포함되어야합니다.
        <ul>
          <li>보류 중 (아직 Zencoder에 제출되지 않음)</li>
          <li>제출 중 (현재 Zencoder에 제출 중)</li>
          <li>트랜스 코딩 (Zencoder에 성공적으로 제출 됨)</li>
          <li>완료 됨 (Zencoder가 트랜스 코딩을 완료하고 작업이 완료 됨)</li>
          <li>실패 (Zencoder가 비디오를 트랜스 코딩 할 수 없음)</li>
        </ul>
      </li>
      <li>새 비디오가 수집되면 비디오를 '제출 중' 상태로 저장하고 백그라운드 작업을 트리거하여 비디오를 Zencoder에 제출합니다.
        <pre class="line-numbers">
<code class="language-ruby" translate="No"># got a new video!
video = Video.new(params)
video.state = "submitting"
video.save!
submit_to_zencoder(video)</code></pre>

        <p>정말로 submit_to_zencoder 메소드를 배경으로해야합니다. Ruby에서 DelayedJob을 사용하면 다음과 같이 보일 수 있습니다.</p>

        <pre class="line-numbers">
<code class="language-ruby" translate="No">delay.submit_to_zencoder(video)</code></pre>

        <p>하지만 우리는 예를 들어 우리의<code translate="No">submit_to_zencoder(video)</code>방법을 고수할 것입니다.</p>
      </li>
      <li>이<code translate="No">submit_to_zencoder</code>함수는 다음과 같습니다. 이것은 백그라운드에서 비동기 적으로 실행되어야합니다.
        <pre class="line-numbers">
<code class="language-ruby" translate="No">def submit_to_zencoder(video)
begin
response = Zencoder::Job.create(attributes, :timeout =&gt; 30_000)
if response.code == 201
video.state = "transcoding"
else
video.state = "pending"
end

video.save!

# Rescue any connection error. Our plugin abstracts these as
# Zencoder::HTTPError.
#
# If you're not using the Zencoder plugin, this includes things
# like Errno::ECONNRESET, Errno::ETIMEDOUT, Errno::ECONNREFUSED,
# Errno::EHOSTDOWN, and SocketError.

rescue Timeout::Error, Zencoder::HTTPError
video.state = "pending"
video.save!
end
end</code></pre>
      </li>
      <li>매분마다 (예: 매분마다) '보류 중' 상태인 작업을 다시 제출하십시오.
        <pre class="line-numbers">
<code class="language-ruby" translate="No">def resubmit_pending_jobs
Video.where(:state =&gt; "pending").find_each do |video|
begin
video.state = "submitting"
video.save!

submit_to_zencoder(video)
rescue ActiveRecord::StaleObjectError
end
end
end
</code></pre>

        <p>또한 비디오 테이블에 'lock_version' 열을 추가하여 낙관적 잠금을 도입합니다. 즉, 레코드가 다음 사이에 업데이트되면<code translate="No">Video.find</code>쿼리 및<code translate="No">video.save</code> , Zencoder에 작업을 제출하지 않습니다. 이렇게하면 작업이 실수로 Zencoder에 두 번 제출되는 것을 방지 할 수 있습니다. 비관적 또는 데이터베이스 잠금 또는 다른 잠금 방법을 사용하여 동일한 작업을 수행 할 수 있습니다.</p>

        <h2>아주 쉽습니다...</h2>

        <p>모든 것을 고려할 때 이것은 Zencoder와 애플리케이션 간의 100 % 통합 안정성을 보장하는 매우 간단한 접근 방식입니다. 순진하게 작업을 제출하는 것보다 몇 단계가 더 필요합니다. 그러나 간헐적 인 시간 초과, Zencoder의 예상치 못한 다운 타임 또는 예정된 유지 관리 등 어떤 일이 발생하더라도 앱이 안정적으로 실행되도록합니다.</p>
      </li>
    </ol>
  </section>
</article>